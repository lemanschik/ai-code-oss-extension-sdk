// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: host/window.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../../bufbuild/protobuf/wire";
import { Metadata } from "../cline/common";
export var ShowMessageType;
(function (ShowMessageType) {
    ShowMessageType[ShowMessageType["ERROR"] = 0] = "ERROR";
    ShowMessageType[ShowMessageType["INFORMATION"] = 1] = "INFORMATION";
    ShowMessageType[ShowMessageType["WARNING"] = 2] = "WARNING";
    ShowMessageType[ShowMessageType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ShowMessageType || (ShowMessageType = {}));
export function showMessageTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ERROR":
            return ShowMessageType.ERROR;
        case 1:
        case "INFORMATION":
            return ShowMessageType.INFORMATION;
        case 2:
        case "WARNING":
            return ShowMessageType.WARNING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ShowMessageType.UNRECOGNIZED;
    }
}
export function showMessageTypeToJSON(object) {
    switch (object) {
        case ShowMessageType.ERROR:
            return "ERROR";
        case ShowMessageType.INFORMATION:
            return "INFORMATION";
        case ShowMessageType.WARNING:
            return "WARNING";
        case ShowMessageType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseShowTextDocumentRequest() {
    return { metadata: undefined, path: "", options: undefined };
}
export const ShowTextDocumentRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.path !== "") {
            writer.uint32(18).string(message.path);
        }
        if (message.options !== undefined) {
            ShowTextDocumentOptions.encode(message.options, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowTextDocumentRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.options = ShowTextDocumentOptions.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            path: isSet(object.path) ? globalThis.String(object.path) : "",
            options: isSet(object.options) ? ShowTextDocumentOptions.fromJSON(object.options) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.path !== "") {
            obj.path = message.path;
        }
        if (message.options !== undefined) {
            obj.options = ShowTextDocumentOptions.toJSON(message.options);
        }
        return obj;
    },
    create(base) {
        return ShowTextDocumentRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowTextDocumentRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.path = object.path ?? "";
        message.options = (object.options !== undefined && object.options !== null)
            ? ShowTextDocumentOptions.fromPartial(object.options)
            : undefined;
        return message;
    },
};
function createBaseShowTextDocumentOptions() {
    return { preview: undefined, preserveFocus: undefined, viewColumn: undefined };
}
export const ShowTextDocumentOptions = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preview !== undefined) {
            writer.uint32(8).bool(message.preview);
        }
        if (message.preserveFocus !== undefined) {
            writer.uint32(16).bool(message.preserveFocus);
        }
        if (message.viewColumn !== undefined) {
            writer.uint32(24).int32(message.viewColumn);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowTextDocumentOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.preview = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.preserveFocus = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.viewColumn = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            preview: isSet(object.preview) ? globalThis.Boolean(object.preview) : undefined,
            preserveFocus: isSet(object.preserveFocus) ? globalThis.Boolean(object.preserveFocus) : undefined,
            viewColumn: isSet(object.viewColumn) ? globalThis.Number(object.viewColumn) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.preview !== undefined) {
            obj.preview = message.preview;
        }
        if (message.preserveFocus !== undefined) {
            obj.preserveFocus = message.preserveFocus;
        }
        if (message.viewColumn !== undefined) {
            obj.viewColumn = Math.round(message.viewColumn);
        }
        return obj;
    },
    create(base) {
        return ShowTextDocumentOptions.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowTextDocumentOptions();
        message.preview = object.preview ?? undefined;
        message.preserveFocus = object.preserveFocus ?? undefined;
        message.viewColumn = object.viewColumn ?? undefined;
        return message;
    },
};
function createBaseTextEditorInfo() {
    return { documentPath: "", viewColumn: undefined, isActive: false };
}
export const TextEditorInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.documentPath !== "") {
            writer.uint32(10).string(message.documentPath);
        }
        if (message.viewColumn !== undefined) {
            writer.uint32(16).int32(message.viewColumn);
        }
        if (message.isActive !== false) {
            writer.uint32(24).bool(message.isActive);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTextEditorInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.documentPath = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.viewColumn = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.isActive = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            documentPath: isSet(object.documentPath) ? globalThis.String(object.documentPath) : "",
            viewColumn: isSet(object.viewColumn) ? globalThis.Number(object.viewColumn) : undefined,
            isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.documentPath !== "") {
            obj.documentPath = message.documentPath;
        }
        if (message.viewColumn !== undefined) {
            obj.viewColumn = Math.round(message.viewColumn);
        }
        if (message.isActive !== false) {
            obj.isActive = message.isActive;
        }
        return obj;
    },
    create(base) {
        return TextEditorInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTextEditorInfo();
        message.documentPath = object.documentPath ?? "";
        message.viewColumn = object.viewColumn ?? undefined;
        message.isActive = object.isActive ?? false;
        return message;
    },
};
function createBaseShowOpenDialogueRequest() {
    return { metadata: undefined, canSelectMany: undefined, openLabel: undefined, filters: undefined };
}
export const ShowOpenDialogueRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.canSelectMany !== undefined) {
            writer.uint32(16).bool(message.canSelectMany);
        }
        if (message.openLabel !== undefined) {
            writer.uint32(26).string(message.openLabel);
        }
        if (message.filters !== undefined) {
            ShowOpenDialogueFilterOption.encode(message.filters, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowOpenDialogueRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.canSelectMany = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.openLabel = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.filters = ShowOpenDialogueFilterOption.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            canSelectMany: isSet(object.canSelectMany) ? globalThis.Boolean(object.canSelectMany) : undefined,
            openLabel: isSet(object.openLabel) ? globalThis.String(object.openLabel) : undefined,
            filters: isSet(object.filters) ? ShowOpenDialogueFilterOption.fromJSON(object.filters) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.canSelectMany !== undefined) {
            obj.canSelectMany = message.canSelectMany;
        }
        if (message.openLabel !== undefined) {
            obj.openLabel = message.openLabel;
        }
        if (message.filters !== undefined) {
            obj.filters = ShowOpenDialogueFilterOption.toJSON(message.filters);
        }
        return obj;
    },
    create(base) {
        return ShowOpenDialogueRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowOpenDialogueRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.canSelectMany = object.canSelectMany ?? undefined;
        message.openLabel = object.openLabel ?? undefined;
        message.filters = (object.filters !== undefined && object.filters !== null)
            ? ShowOpenDialogueFilterOption.fromPartial(object.filters)
            : undefined;
        return message;
    },
};
function createBaseShowOpenDialogueFilterOption() {
    return { files: [] };
}
export const ShowOpenDialogueFilterOption = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.files) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowOpenDialogueFilterOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.files.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.files?.length) {
            obj.files = message.files;
        }
        return obj;
    },
    create(base) {
        return ShowOpenDialogueFilterOption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowOpenDialogueFilterOption();
        message.files = object.files?.map((e) => e) || [];
        return message;
    },
};
function createBaseSelectedResources() {
    return { paths: [] };
}
export const SelectedResources = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.paths) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelectedResources();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create(base) {
        return SelectedResources.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSelectedResources();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
    },
};
function createBaseShowMessageRequest() {
    return { metadata: undefined, type: 0, message: "", options: undefined };
}
export const ShowMessageRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.message !== "") {
            writer.uint32(26).string(message.message);
        }
        if (message.options !== undefined) {
            ShowMessageRequestOptions.encode(message.options, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.options = ShowMessageRequestOptions.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            type: isSet(object.type) ? showMessageTypeFromJSON(object.type) : 0,
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            options: isSet(object.options) ? ShowMessageRequestOptions.fromJSON(object.options) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.type !== 0) {
            obj.type = showMessageTypeToJSON(message.type);
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.options !== undefined) {
            obj.options = ShowMessageRequestOptions.toJSON(message.options);
        }
        return obj;
    },
    create(base) {
        return ShowMessageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowMessageRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.type = object.type ?? 0;
        message.message = object.message ?? "";
        message.options = (object.options !== undefined && object.options !== null)
            ? ShowMessageRequestOptions.fromPartial(object.options)
            : undefined;
        return message;
    },
};
function createBaseShowMessageRequestOptions() {
    return { items: [], modal: undefined, detail: undefined };
}
export const ShowMessageRequestOptions = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.items) {
            writer.uint32(10).string(v);
        }
        if (message.modal !== undefined) {
            writer.uint32(16).bool(message.modal);
        }
        if (message.detail !== undefined) {
            writer.uint32(26).string(message.detail);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowMessageRequestOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.items.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.modal = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.detail = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => globalThis.String(e)) : [],
            modal: isSet(object.modal) ? globalThis.Boolean(object.modal) : undefined,
            detail: isSet(object.detail) ? globalThis.String(object.detail) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.items?.length) {
            obj.items = message.items;
        }
        if (message.modal !== undefined) {
            obj.modal = message.modal;
        }
        if (message.detail !== undefined) {
            obj.detail = message.detail;
        }
        return obj;
    },
    create(base) {
        return ShowMessageRequestOptions.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowMessageRequestOptions();
        message.items = object.items?.map((e) => e) || [];
        message.modal = object.modal ?? undefined;
        message.detail = object.detail ?? undefined;
        return message;
    },
};
function createBaseSelectedResponse() {
    return { selectedOption: undefined };
}
export const SelectedResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.selectedOption !== undefined) {
            writer.uint32(10).string(message.selectedOption);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelectedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.selectedOption = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { selectedOption: isSet(object.selectedOption) ? globalThis.String(object.selectedOption) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.selectedOption !== undefined) {
            obj.selectedOption = message.selectedOption;
        }
        return obj;
    },
    create(base) {
        return SelectedResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSelectedResponse();
        message.selectedOption = object.selectedOption ?? undefined;
        return message;
    },
};
function createBaseShowSaveDialogRequest() {
    return { metadata: undefined, options: undefined };
}
export const ShowSaveDialogRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.options !== undefined) {
            ShowSaveDialogOptions.encode(message.options, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowSaveDialogRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.options = ShowSaveDialogOptions.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            options: isSet(object.options) ? ShowSaveDialogOptions.fromJSON(object.options) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.options !== undefined) {
            obj.options = ShowSaveDialogOptions.toJSON(message.options);
        }
        return obj;
    },
    create(base) {
        return ShowSaveDialogRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowSaveDialogRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.options = (object.options !== undefined && object.options !== null)
            ? ShowSaveDialogOptions.fromPartial(object.options)
            : undefined;
        return message;
    },
};
function createBaseShowSaveDialogOptions() {
    return { defaultPath: undefined, filters: {} };
}
export const ShowSaveDialogOptions = {
    encode(message, writer = new BinaryWriter()) {
        if (message.defaultPath !== undefined) {
            writer.uint32(10).string(message.defaultPath);
        }
        Object.entries(message.filters).forEach(([key, value]) => {
            ShowSaveDialogOptions_FiltersEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowSaveDialogOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.defaultPath = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = ShowSaveDialogOptions_FiltersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.filters[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultPath: isSet(object.defaultPath) ? globalThis.String(object.defaultPath) : undefined,
            filters: isObject(object.filters)
                ? Object.entries(object.filters).reduce((acc, [key, value]) => {
                    acc[key] = FileExtensionList.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.defaultPath !== undefined) {
            obj.defaultPath = message.defaultPath;
        }
        if (message.filters) {
            const entries = Object.entries(message.filters);
            if (entries.length > 0) {
                obj.filters = {};
                entries.forEach(([k, v]) => {
                    obj.filters[k] = FileExtensionList.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ShowSaveDialogOptions.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowSaveDialogOptions();
        message.defaultPath = object.defaultPath ?? undefined;
        message.filters = Object.entries(object.filters ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = FileExtensionList.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseShowSaveDialogOptions_FiltersEntry() {
    return { key: "", value: undefined };
}
export const ShowSaveDialogOptions_FiltersEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            FileExtensionList.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowSaveDialogOptions_FiltersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = FileExtensionList.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? FileExtensionList.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = FileExtensionList.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ShowSaveDialogOptions_FiltersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowSaveDialogOptions_FiltersEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? FileExtensionList.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseFileExtensionList() {
    return { extensions: [] };
}
export const FileExtensionList = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.extensions) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFileExtensionList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.extensions.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            extensions: globalThis.Array.isArray(object?.extensions)
                ? object.extensions.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.extensions?.length) {
            obj.extensions = message.extensions;
        }
        return obj;
    },
    create(base) {
        return FileExtensionList.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFileExtensionList();
        message.extensions = object.extensions?.map((e) => e) || [];
        return message;
    },
};
function createBaseShowSaveDialogResponse() {
    return { selectedPath: undefined };
}
export const ShowSaveDialogResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.selectedPath !== undefined) {
            writer.uint32(10).string(message.selectedPath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowSaveDialogResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.selectedPath = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { selectedPath: isSet(object.selectedPath) ? globalThis.String(object.selectedPath) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.selectedPath !== undefined) {
            obj.selectedPath = message.selectedPath;
        }
        return obj;
    },
    create(base) {
        return ShowSaveDialogResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowSaveDialogResponse();
        message.selectedPath = object.selectedPath ?? undefined;
        return message;
    },
};
function createBaseShowInputBoxRequest() {
    return { metadata: undefined, title: "", prompt: undefined, value: undefined };
}
export const ShowInputBoxRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.title !== "") {
            writer.uint32(18).string(message.title);
        }
        if (message.prompt !== undefined) {
            writer.uint32(26).string(message.prompt);
        }
        if (message.value !== undefined) {
            writer.uint32(34).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowInputBoxRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.prompt = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : undefined,
            value: isSet(object.value) ? globalThis.String(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.prompt !== undefined) {
            obj.prompt = message.prompt;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return ShowInputBoxRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowInputBoxRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.title = object.title ?? "";
        message.prompt = object.prompt ?? undefined;
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseShowInputBoxResponse() {
    return { response: undefined };
}
export const ShowInputBoxResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.response !== undefined) {
            writer.uint32(10).string(message.response);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseShowInputBoxResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.response = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { response: isSet(object.response) ? globalThis.String(object.response) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.response !== undefined) {
            obj.response = message.response;
        }
        return obj;
    },
    create(base) {
        return ShowInputBoxResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseShowInputBoxResponse();
        message.response = object.response ?? undefined;
        return message;
    },
};
function createBaseOpenFileRequest() {
    return { metadata: undefined, filePath: "" };
}
export const OpenFileRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.filePath !== "") {
            writer.uint32(18).string(message.filePath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenFileRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        return obj;
    },
    create(base) {
        return OpenFileRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOpenFileRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.filePath = object.filePath ?? "";
        return message;
    },
};
function createBaseOpenFileResponse() {
    return {};
}
export const OpenFileResponse = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenFileResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return OpenFileResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseOpenFileResponse();
        return message;
    },
};
function createBaseGetOpenTabsRequest() {
    return {};
}
export const GetOpenTabsRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOpenTabsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return GetOpenTabsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseGetOpenTabsRequest();
        return message;
    },
};
function createBaseGetOpenTabsResponse() {
    return { paths: [] };
}
export const GetOpenTabsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.paths) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOpenTabsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create(base) {
        return GetOpenTabsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetOpenTabsResponse();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetVisibleTabsRequest() {
    return {};
}
export const GetVisibleTabsRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetVisibleTabsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return GetVisibleTabsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseGetVisibleTabsRequest();
        return message;
    },
};
function createBaseGetVisibleTabsResponse() {
    return { paths: [] };
}
export const GetVisibleTabsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.paths) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetVisibleTabsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create(base) {
        return GetVisibleTabsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetVisibleTabsResponse();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
    },
};
export const WindowServiceDefinition = {
    name: "WindowService",
    fullName: "host.WindowService",
    methods: {
        /** Opens a text document in the editor and returns editor information. */
        showTextDocument: {
            name: "showTextDocument",
            requestType: ShowTextDocumentRequest,
            requestStream: false,
            responseType: TextEditorInfo,
            responseStream: false,
            options: {},
        },
        showOpenDialogue: {
            name: "showOpenDialogue",
            requestType: ShowOpenDialogueRequest,
            requestStream: false,
            responseType: SelectedResources,
            responseStream: false,
            options: {},
        },
        showMessage: {
            name: "showMessage",
            requestType: ShowMessageRequest,
            requestStream: false,
            responseType: SelectedResponse,
            responseStream: false,
            options: {},
        },
        showInputBox: {
            name: "showInputBox",
            requestType: ShowInputBoxRequest,
            requestStream: false,
            responseType: ShowInputBoxResponse,
            responseStream: false,
            options: {},
        },
        showSaveDialog: {
            name: "showSaveDialog",
            requestType: ShowSaveDialogRequest,
            requestStream: false,
            responseType: ShowSaveDialogResponse,
            responseStream: false,
            options: {},
        },
        openFile: {
            name: "openFile",
            requestType: OpenFileRequest,
            requestStream: false,
            responseType: OpenFileResponse,
            responseStream: false,
            options: {},
        },
        getOpenTabs: {
            name: "getOpenTabs",
            requestType: GetOpenTabsRequest,
            requestStream: false,
            responseType: GetOpenTabsResponse,
            responseStream: false,
            options: {},
        },
        getVisibleTabs: {
            name: "getVisibleTabs",
            requestType: GetVisibleTabsRequest,
            requestStream: false,
            responseType: GetVisibleTabsResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
