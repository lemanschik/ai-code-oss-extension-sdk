// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: cline/mcp.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../../bufbuild/protobuf/wire";
import { Empty, EmptyRequest, Metadata, StringRequest } from "./common";
export var McpServerStatus;
(function (McpServerStatus) {
    /**
     * MCP_SERVER_STATUS_DISCONNECTED - Protobuf enums (in proto3) must have a zero value defined, which serves as the default if the field isn't explicitly set.
     * To align with the required nature of the TypeScript type and avoid an unnecessary UNSPECIFIED state, we map one of the existing statuses to this zero value.
     */
    McpServerStatus[McpServerStatus["MCP_SERVER_STATUS_DISCONNECTED"] = 0] = "MCP_SERVER_STATUS_DISCONNECTED";
    McpServerStatus[McpServerStatus["MCP_SERVER_STATUS_CONNECTED"] = 1] = "MCP_SERVER_STATUS_CONNECTED";
    McpServerStatus[McpServerStatus["MCP_SERVER_STATUS_CONNECTING"] = 2] = "MCP_SERVER_STATUS_CONNECTING";
    McpServerStatus[McpServerStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(McpServerStatus || (McpServerStatus = {}));
export function mcpServerStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "MCP_SERVER_STATUS_DISCONNECTED":
            return McpServerStatus.MCP_SERVER_STATUS_DISCONNECTED;
        case 1:
        case "MCP_SERVER_STATUS_CONNECTED":
            return McpServerStatus.MCP_SERVER_STATUS_CONNECTED;
        case 2:
        case "MCP_SERVER_STATUS_CONNECTING":
            return McpServerStatus.MCP_SERVER_STATUS_CONNECTING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return McpServerStatus.UNRECOGNIZED;
    }
}
export function mcpServerStatusToJSON(object) {
    switch (object) {
        case McpServerStatus.MCP_SERVER_STATUS_DISCONNECTED:
            return "MCP_SERVER_STATUS_DISCONNECTED";
        case McpServerStatus.MCP_SERVER_STATUS_CONNECTED:
            return "MCP_SERVER_STATUS_CONNECTED";
        case McpServerStatus.MCP_SERVER_STATUS_CONNECTING:
            return "MCP_SERVER_STATUS_CONNECTING";
        case McpServerStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseToggleMcpServerRequest() {
    return { metadata: undefined, serverName: "", disabled: false };
}
export const ToggleMcpServerRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.serverName !== "") {
            writer.uint32(18).string(message.serverName);
        }
        if (message.disabled !== false) {
            writer.uint32(24).bool(message.disabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleMcpServerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.serverName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
            disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.serverName !== "") {
            obj.serverName = message.serverName;
        }
        if (message.disabled !== false) {
            obj.disabled = message.disabled;
        }
        return obj;
    },
    create(base) {
        return ToggleMcpServerRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleMcpServerRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.serverName = object.serverName ?? "";
        message.disabled = object.disabled ?? false;
        return message;
    },
};
function createBaseUpdateMcpTimeoutRequest() {
    return { metadata: undefined, serverName: "", timeout: 0 };
}
export const UpdateMcpTimeoutRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.serverName !== "") {
            writer.uint32(18).string(message.serverName);
        }
        if (message.timeout !== 0) {
            writer.uint32(24).int32(message.timeout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateMcpTimeoutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.serverName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.timeout = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
            timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.serverName !== "") {
            obj.serverName = message.serverName;
        }
        if (message.timeout !== 0) {
            obj.timeout = Math.round(message.timeout);
        }
        return obj;
    },
    create(base) {
        return UpdateMcpTimeoutRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateMcpTimeoutRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.serverName = object.serverName ?? "";
        message.timeout = object.timeout ?? 0;
        return message;
    },
};
function createBaseAddRemoteMcpServerRequest() {
    return { metadata: undefined, serverName: "", serverUrl: "" };
}
export const AddRemoteMcpServerRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.serverName !== "") {
            writer.uint32(18).string(message.serverName);
        }
        if (message.serverUrl !== "") {
            writer.uint32(26).string(message.serverUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddRemoteMcpServerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.serverName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.serverUrl = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
            serverUrl: isSet(object.serverUrl) ? globalThis.String(object.serverUrl) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.serverName !== "") {
            obj.serverName = message.serverName;
        }
        if (message.serverUrl !== "") {
            obj.serverUrl = message.serverUrl;
        }
        return obj;
    },
    create(base) {
        return AddRemoteMcpServerRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddRemoteMcpServerRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.serverName = object.serverName ?? "";
        message.serverUrl = object.serverUrl ?? "";
        return message;
    },
};
function createBaseToggleToolAutoApproveRequest() {
    return { metadata: undefined, serverName: "", toolNames: [], autoApprove: false };
}
export const ToggleToolAutoApproveRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.serverName !== "") {
            writer.uint32(18).string(message.serverName);
        }
        for (const v of message.toolNames) {
            writer.uint32(26).string(v);
        }
        if (message.autoApprove !== false) {
            writer.uint32(32).bool(message.autoApprove);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleToolAutoApproveRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.serverName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.toolNames.push(reader.string());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.autoApprove = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
            toolNames: globalThis.Array.isArray(object?.toolNames)
                ? object.toolNames.map((e) => globalThis.String(e))
                : [],
            autoApprove: isSet(object.autoApprove) ? globalThis.Boolean(object.autoApprove) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.serverName !== "") {
            obj.serverName = message.serverName;
        }
        if (message.toolNames?.length) {
            obj.toolNames = message.toolNames;
        }
        if (message.autoApprove !== false) {
            obj.autoApprove = message.autoApprove;
        }
        return obj;
    },
    create(base) {
        return ToggleToolAutoApproveRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleToolAutoApproveRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.serverName = object.serverName ?? "";
        message.toolNames = object.toolNames?.map((e) => e) || [];
        message.autoApprove = object.autoApprove ?? false;
        return message;
    },
};
function createBaseMcpTool() {
    return { name: "", description: undefined, inputSchema: undefined, autoApprove: undefined };
}
export const McpTool = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        if (message.inputSchema !== undefined) {
            writer.uint32(26).string(message.inputSchema);
        }
        if (message.autoApprove !== undefined) {
            writer.uint32(32).bool(message.autoApprove);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpTool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.inputSchema = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.autoApprove = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            inputSchema: isSet(object.inputSchema) ? globalThis.String(object.inputSchema) : undefined,
            autoApprove: isSet(object.autoApprove) ? globalThis.Boolean(object.autoApprove) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.inputSchema !== undefined) {
            obj.inputSchema = message.inputSchema;
        }
        if (message.autoApprove !== undefined) {
            obj.autoApprove = message.autoApprove;
        }
        return obj;
    },
    create(base) {
        return McpTool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpTool();
        message.name = object.name ?? "";
        message.description = object.description ?? undefined;
        message.inputSchema = object.inputSchema ?? undefined;
        message.autoApprove = object.autoApprove ?? undefined;
        return message;
    },
};
function createBaseMcpResource() {
    return { uri: "", name: "", mimeType: undefined, description: undefined };
}
export const McpResource = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uri !== "") {
            writer.uint32(10).string(message.uri);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.mimeType !== undefined) {
            writer.uint32(26).string(message.mimeType);
        }
        if (message.description !== undefined) {
            writer.uint32(34).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpResource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uri = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.mimeType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : undefined,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uri !== "") {
            obj.uri = message.uri;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.mimeType !== undefined) {
            obj.mimeType = message.mimeType;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return McpResource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpResource();
        message.uri = object.uri ?? "";
        message.name = object.name ?? "";
        message.mimeType = object.mimeType ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseMcpResourceTemplate() {
    return { uriTemplate: "", name: "", mimeType: undefined, description: undefined };
}
export const McpResourceTemplate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uriTemplate !== "") {
            writer.uint32(10).string(message.uriTemplate);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.mimeType !== undefined) {
            writer.uint32(26).string(message.mimeType);
        }
        if (message.description !== undefined) {
            writer.uint32(34).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpResourceTemplate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uriTemplate = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.mimeType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uriTemplate: isSet(object.uriTemplate) ? globalThis.String(object.uriTemplate) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : undefined,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uriTemplate !== "") {
            obj.uriTemplate = message.uriTemplate;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.mimeType !== undefined) {
            obj.mimeType = message.mimeType;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return McpResourceTemplate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpResourceTemplate();
        message.uriTemplate = object.uriTemplate ?? "";
        message.name = object.name ?? "";
        message.mimeType = object.mimeType ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseMcpServer() {
    return {
        name: "",
        config: "",
        status: 0,
        error: undefined,
        tools: [],
        resources: [],
        resourceTemplates: [],
        disabled: undefined,
        timeout: undefined,
    };
}
export const McpServer = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.config !== "") {
            writer.uint32(18).string(message.config);
        }
        if (message.status !== 0) {
            writer.uint32(24).int32(message.status);
        }
        if (message.error !== undefined) {
            writer.uint32(34).string(message.error);
        }
        for (const v of message.tools) {
            McpTool.encode(v, writer.uint32(42).fork()).join();
        }
        for (const v of message.resources) {
            McpResource.encode(v, writer.uint32(50).fork()).join();
        }
        for (const v of message.resourceTemplates) {
            McpResourceTemplate.encode(v, writer.uint32(58).fork()).join();
        }
        if (message.disabled !== undefined) {
            writer.uint32(64).bool(message.disabled);
        }
        if (message.timeout !== undefined) {
            writer.uint32(72).int32(message.timeout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpServer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.config = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.tools.push(McpTool.decode(reader, reader.uint32()));
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.resources.push(McpResource.decode(reader, reader.uint32()));
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.resourceTemplates.push(McpResourceTemplate.decode(reader, reader.uint32()));
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.timeout = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            config: isSet(object.config) ? globalThis.String(object.config) : "",
            status: isSet(object.status) ? mcpServerStatusFromJSON(object.status) : 0,
            error: isSet(object.error) ? globalThis.String(object.error) : undefined,
            tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e) => McpTool.fromJSON(e)) : [],
            resources: globalThis.Array.isArray(object?.resources)
                ? object.resources.map((e) => McpResource.fromJSON(e))
                : [],
            resourceTemplates: globalThis.Array.isArray(object?.resourceTemplates)
                ? object.resourceTemplates.map((e) => McpResourceTemplate.fromJSON(e))
                : [],
            disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : undefined,
            timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.config !== "") {
            obj.config = message.config;
        }
        if (message.status !== 0) {
            obj.status = mcpServerStatusToJSON(message.status);
        }
        if (message.error !== undefined) {
            obj.error = message.error;
        }
        if (message.tools?.length) {
            obj.tools = message.tools.map((e) => McpTool.toJSON(e));
        }
        if (message.resources?.length) {
            obj.resources = message.resources.map((e) => McpResource.toJSON(e));
        }
        if (message.resourceTemplates?.length) {
            obj.resourceTemplates = message.resourceTemplates.map((e) => McpResourceTemplate.toJSON(e));
        }
        if (message.disabled !== undefined) {
            obj.disabled = message.disabled;
        }
        if (message.timeout !== undefined) {
            obj.timeout = Math.round(message.timeout);
        }
        return obj;
    },
    create(base) {
        return McpServer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpServer();
        message.name = object.name ?? "";
        message.config = object.config ?? "";
        message.status = object.status ?? 0;
        message.error = object.error ?? undefined;
        message.tools = object.tools?.map((e) => McpTool.fromPartial(e)) || [];
        message.resources = object.resources?.map((e) => McpResource.fromPartial(e)) || [];
        message.resourceTemplates = object.resourceTemplates?.map((e) => McpResourceTemplate.fromPartial(e)) || [];
        message.disabled = object.disabled ?? undefined;
        message.timeout = object.timeout ?? undefined;
        return message;
    },
};
function createBaseMcpServers() {
    return { mcpServers: [] };
}
export const McpServers = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.mcpServers) {
            McpServer.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpServers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.mcpServers.push(McpServer.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mcpServers: globalThis.Array.isArray(object?.mcpServers)
                ? object.mcpServers.map((e) => McpServer.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mcpServers?.length) {
            obj.mcpServers = message.mcpServers.map((e) => McpServer.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return McpServers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpServers();
        message.mcpServers = object.mcpServers?.map((e) => McpServer.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMcpMarketplaceItem() {
    return {
        mcpId: "",
        githubUrl: "",
        name: "",
        author: "",
        description: "",
        codiconIcon: "",
        logoUrl: "",
        category: "",
        tags: [],
        requiresApiKey: false,
        readmeContent: undefined,
        llmsInstallationContent: undefined,
        isRecommended: false,
        githubStars: 0,
        downloadCount: 0,
        createdAt: "",
        updatedAt: "",
        lastGithubSync: "",
    };
}
export const McpMarketplaceItem = {
    encode(message, writer = new BinaryWriter()) {
        if (message.mcpId !== "") {
            writer.uint32(10).string(message.mcpId);
        }
        if (message.githubUrl !== "") {
            writer.uint32(18).string(message.githubUrl);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.author !== "") {
            writer.uint32(34).string(message.author);
        }
        if (message.description !== "") {
            writer.uint32(42).string(message.description);
        }
        if (message.codiconIcon !== "") {
            writer.uint32(50).string(message.codiconIcon);
        }
        if (message.logoUrl !== "") {
            writer.uint32(58).string(message.logoUrl);
        }
        if (message.category !== "") {
            writer.uint32(66).string(message.category);
        }
        for (const v of message.tags) {
            writer.uint32(74).string(v);
        }
        if (message.requiresApiKey !== false) {
            writer.uint32(80).bool(message.requiresApiKey);
        }
        if (message.readmeContent !== undefined) {
            writer.uint32(90).string(message.readmeContent);
        }
        if (message.llmsInstallationContent !== undefined) {
            writer.uint32(98).string(message.llmsInstallationContent);
        }
        if (message.isRecommended !== false) {
            writer.uint32(104).bool(message.isRecommended);
        }
        if (message.githubStars !== 0) {
            writer.uint32(112).int32(message.githubStars);
        }
        if (message.downloadCount !== 0) {
            writer.uint32(120).int32(message.downloadCount);
        }
        if (message.createdAt !== "") {
            writer.uint32(130).string(message.createdAt);
        }
        if (message.updatedAt !== "") {
            writer.uint32(138).string(message.updatedAt);
        }
        if (message.lastGithubSync !== "") {
            writer.uint32(146).string(message.lastGithubSync);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpMarketplaceItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.mcpId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.githubUrl = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.author = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.codiconIcon = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.logoUrl = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.category = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.tags.push(reader.string());
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.requiresApiKey = reader.bool();
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.readmeContent = reader.string();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.llmsInstallationContent = reader.string();
                    continue;
                }
                case 13: {
                    if (tag !== 104) {
                        break;
                    }
                    message.isRecommended = reader.bool();
                    continue;
                }
                case 14: {
                    if (tag !== 112) {
                        break;
                    }
                    message.githubStars = reader.int32();
                    continue;
                }
                case 15: {
                    if (tag !== 120) {
                        break;
                    }
                    message.downloadCount = reader.int32();
                    continue;
                }
                case 16: {
                    if (tag !== 130) {
                        break;
                    }
                    message.createdAt = reader.string();
                    continue;
                }
                case 17: {
                    if (tag !== 138) {
                        break;
                    }
                    message.updatedAt = reader.string();
                    continue;
                }
                case 18: {
                    if (tag !== 146) {
                        break;
                    }
                    message.lastGithubSync = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "",
            githubUrl: isSet(object.githubUrl) ? globalThis.String(object.githubUrl) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            author: isSet(object.author) ? globalThis.String(object.author) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            codiconIcon: isSet(object.codiconIcon) ? globalThis.String(object.codiconIcon) : "",
            logoUrl: isSet(object.logoUrl) ? globalThis.String(object.logoUrl) : "",
            category: isSet(object.category) ? globalThis.String(object.category) : "",
            tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => globalThis.String(e)) : [],
            requiresApiKey: isSet(object.requiresApiKey) ? globalThis.Boolean(object.requiresApiKey) : false,
            readmeContent: isSet(object.readmeContent) ? globalThis.String(object.readmeContent) : undefined,
            llmsInstallationContent: isSet(object.llmsInstallationContent)
                ? globalThis.String(object.llmsInstallationContent)
                : undefined,
            isRecommended: isSet(object.isRecommended) ? globalThis.Boolean(object.isRecommended) : false,
            githubStars: isSet(object.githubStars) ? globalThis.Number(object.githubStars) : 0,
            downloadCount: isSet(object.downloadCount) ? globalThis.Number(object.downloadCount) : 0,
            createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
            updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
            lastGithubSync: isSet(object.lastGithubSync) ? globalThis.String(object.lastGithubSync) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mcpId !== "") {
            obj.mcpId = message.mcpId;
        }
        if (message.githubUrl !== "") {
            obj.githubUrl = message.githubUrl;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.author !== "") {
            obj.author = message.author;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.codiconIcon !== "") {
            obj.codiconIcon = message.codiconIcon;
        }
        if (message.logoUrl !== "") {
            obj.logoUrl = message.logoUrl;
        }
        if (message.category !== "") {
            obj.category = message.category;
        }
        if (message.tags?.length) {
            obj.tags = message.tags;
        }
        if (message.requiresApiKey !== false) {
            obj.requiresApiKey = message.requiresApiKey;
        }
        if (message.readmeContent !== undefined) {
            obj.readmeContent = message.readmeContent;
        }
        if (message.llmsInstallationContent !== undefined) {
            obj.llmsInstallationContent = message.llmsInstallationContent;
        }
        if (message.isRecommended !== false) {
            obj.isRecommended = message.isRecommended;
        }
        if (message.githubStars !== 0) {
            obj.githubStars = Math.round(message.githubStars);
        }
        if (message.downloadCount !== 0) {
            obj.downloadCount = Math.round(message.downloadCount);
        }
        if (message.createdAt !== "") {
            obj.createdAt = message.createdAt;
        }
        if (message.updatedAt !== "") {
            obj.updatedAt = message.updatedAt;
        }
        if (message.lastGithubSync !== "") {
            obj.lastGithubSync = message.lastGithubSync;
        }
        return obj;
    },
    create(base) {
        return McpMarketplaceItem.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpMarketplaceItem();
        message.mcpId = object.mcpId ?? "";
        message.githubUrl = object.githubUrl ?? "";
        message.name = object.name ?? "";
        message.author = object.author ?? "";
        message.description = object.description ?? "";
        message.codiconIcon = object.codiconIcon ?? "";
        message.logoUrl = object.logoUrl ?? "";
        message.category = object.category ?? "";
        message.tags = object.tags?.map((e) => e) || [];
        message.requiresApiKey = object.requiresApiKey ?? false;
        message.readmeContent = object.readmeContent ?? undefined;
        message.llmsInstallationContent = object.llmsInstallationContent ?? undefined;
        message.isRecommended = object.isRecommended ?? false;
        message.githubStars = object.githubStars ?? 0;
        message.downloadCount = object.downloadCount ?? 0;
        message.createdAt = object.createdAt ?? "";
        message.updatedAt = object.updatedAt ?? "";
        message.lastGithubSync = object.lastGithubSync ?? "";
        return message;
    },
};
function createBaseMcpMarketplaceCatalog() {
    return { items: [] };
}
export const McpMarketplaceCatalog = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.items) {
            McpMarketplaceItem.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpMarketplaceCatalog();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.items.push(McpMarketplaceItem.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            items: globalThis.Array.isArray(object?.items)
                ? object.items.map((e) => McpMarketplaceItem.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.items?.length) {
            obj.items = message.items.map((e) => McpMarketplaceItem.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return McpMarketplaceCatalog.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpMarketplaceCatalog();
        message.items = object.items?.map((e) => McpMarketplaceItem.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMcpDownloadResponse() {
    return {
        mcpId: "",
        githubUrl: "",
        name: "",
        author: "",
        description: "",
        readmeContent: "",
        llmsInstallationContent: "",
        requiresApiKey: false,
        error: undefined,
    };
}
export const McpDownloadResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.mcpId !== "") {
            writer.uint32(10).string(message.mcpId);
        }
        if (message.githubUrl !== "") {
            writer.uint32(18).string(message.githubUrl);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.author !== "") {
            writer.uint32(34).string(message.author);
        }
        if (message.description !== "") {
            writer.uint32(42).string(message.description);
        }
        if (message.readmeContent !== "") {
            writer.uint32(50).string(message.readmeContent);
        }
        if (message.llmsInstallationContent !== "") {
            writer.uint32(58).string(message.llmsInstallationContent);
        }
        if (message.requiresApiKey !== false) {
            writer.uint32(64).bool(message.requiresApiKey);
        }
        if (message.error !== undefined) {
            writer.uint32(74).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpDownloadResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.mcpId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.githubUrl = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.author = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.readmeContent = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.llmsInstallationContent = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.requiresApiKey = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "",
            githubUrl: isSet(object.githubUrl) ? globalThis.String(object.githubUrl) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            author: isSet(object.author) ? globalThis.String(object.author) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            readmeContent: isSet(object.readmeContent) ? globalThis.String(object.readmeContent) : "",
            llmsInstallationContent: isSet(object.llmsInstallationContent)
                ? globalThis.String(object.llmsInstallationContent)
                : "",
            requiresApiKey: isSet(object.requiresApiKey) ? globalThis.Boolean(object.requiresApiKey) : false,
            error: isSet(object.error) ? globalThis.String(object.error) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mcpId !== "") {
            obj.mcpId = message.mcpId;
        }
        if (message.githubUrl !== "") {
            obj.githubUrl = message.githubUrl;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.author !== "") {
            obj.author = message.author;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.readmeContent !== "") {
            obj.readmeContent = message.readmeContent;
        }
        if (message.llmsInstallationContent !== "") {
            obj.llmsInstallationContent = message.llmsInstallationContent;
        }
        if (message.requiresApiKey !== false) {
            obj.requiresApiKey = message.requiresApiKey;
        }
        if (message.error !== undefined) {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return McpDownloadResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpDownloadResponse();
        message.mcpId = object.mcpId ?? "";
        message.githubUrl = object.githubUrl ?? "";
        message.name = object.name ?? "";
        message.author = object.author ?? "";
        message.description = object.description ?? "";
        message.readmeContent = object.readmeContent ?? "";
        message.llmsInstallationContent = object.llmsInstallationContent ?? "";
        message.requiresApiKey = object.requiresApiKey ?? false;
        message.error = object.error ?? undefined;
        return message;
    },
};
export const McpServiceDefinition = {
    name: "McpService",
    fullName: "cline.McpService",
    methods: {
        toggleMcpServer: {
            name: "toggleMcpServer",
            requestType: ToggleMcpServerRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        updateMcpTimeout: {
            name: "updateMcpTimeout",
            requestType: UpdateMcpTimeoutRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        addRemoteMcpServer: {
            name: "addRemoteMcpServer",
            requestType: AddRemoteMcpServerRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        downloadMcp: {
            name: "downloadMcp",
            requestType: StringRequest,
            requestStream: false,
            responseType: McpDownloadResponse,
            responseStream: false,
            options: {},
        },
        restartMcpServer: {
            name: "restartMcpServer",
            requestType: StringRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        deleteMcpServer: {
            name: "deleteMcpServer",
            requestType: StringRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        toggleToolAutoApprove: {
            name: "toggleToolAutoApprove",
            requestType: ToggleToolAutoApproveRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        refreshMcpMarketplace: {
            name: "refreshMcpMarketplace",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: McpMarketplaceCatalog,
            responseStream: false,
            options: {},
        },
        openMcpSettings: {
            name: "openMcpSettings",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Subscribe to MCP marketplace catalog updates */
        subscribeToMcpMarketplaceCatalog: {
            name: "subscribeToMcpMarketplaceCatalog",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: McpMarketplaceCatalog,
            responseStream: true,
            options: {},
        },
        getLatestMcpServers: {
            name: "getLatestMcpServers",
            requestType: Empty,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        /** Subscribe to MCP server updates */
        subscribeToMcpServers: {
            name: "subscribeToMcpServers",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: true,
            options: {},
        },
    },
};
export const McpServiceService = {
    toggleMcpServer: {
        path: "/cline.McpService/toggleMcpServer",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(ToggleMcpServerRequest.encode(value).finish()),
        requestDeserialize: (value) => ToggleMcpServerRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    updateMcpTimeout: {
        path: "/cline.McpService/updateMcpTimeout",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(UpdateMcpTimeoutRequest.encode(value).finish()),
        requestDeserialize: (value) => UpdateMcpTimeoutRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    addRemoteMcpServer: {
        path: "/cline.McpService/addRemoteMcpServer",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(AddRemoteMcpServerRequest.encode(value).finish()),
        requestDeserialize: (value) => AddRemoteMcpServerRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    downloadMcp: {
        path: "/cline.McpService/downloadMcp",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(StringRequest.encode(value).finish()),
        requestDeserialize: (value) => StringRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpDownloadResponse.encode(value).finish()),
        responseDeserialize: (value) => McpDownloadResponse.decode(value),
    },
    restartMcpServer: {
        path: "/cline.McpService/restartMcpServer",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(StringRequest.encode(value).finish()),
        requestDeserialize: (value) => StringRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    deleteMcpServer: {
        path: "/cline.McpService/deleteMcpServer",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(StringRequest.encode(value).finish()),
        requestDeserialize: (value) => StringRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    toggleToolAutoApprove: {
        path: "/cline.McpService/toggleToolAutoApprove",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(ToggleToolAutoApproveRequest.encode(value).finish()),
        requestDeserialize: (value) => ToggleToolAutoApproveRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    refreshMcpMarketplace: {
        path: "/cline.McpService/refreshMcpMarketplace",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpMarketplaceCatalog.encode(value).finish()),
        responseDeserialize: (value) => McpMarketplaceCatalog.decode(value),
    },
    openMcpSettings: {
        path: "/cline.McpService/openMcpSettings",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(Empty.encode(value).finish()),
        responseDeserialize: (value) => Empty.decode(value),
    },
    /** Subscribe to MCP marketplace catalog updates */
    subscribeToMcpMarketplaceCatalog: {
        path: "/cline.McpService/subscribeToMcpMarketplaceCatalog",
        requestStream: false,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpMarketplaceCatalog.encode(value).finish()),
        responseDeserialize: (value) => McpMarketplaceCatalog.decode(value),
    },
    getLatestMcpServers: {
        path: "/cline.McpService/getLatestMcpServers",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(Empty.encode(value).finish()),
        requestDeserialize: (value) => Empty.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
    /** Subscribe to MCP server updates */
    subscribeToMcpServers: {
        path: "/cline.McpService/subscribeToMcpServers",
        requestStream: false,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(McpServers.encode(value).finish()),
        responseDeserialize: (value) => McpServers.decode(value),
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
