// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: host/workspace.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../../bufbuild/protobuf/wire";
function createBaseGetWorkspacePathsRequest() {
    return { id: undefined };
}
export const GetWorkspacePathsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.id !== undefined) {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWorkspacePathsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? globalThis.String(object.id) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return GetWorkspacePathsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetWorkspacePathsRequest();
        message.id = object.id ?? undefined;
        return message;
    },
};
function createBaseGetWorkspacePathsResponse() {
    return { id: undefined, paths: [] };
}
export const GetWorkspacePathsResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.id !== undefined) {
            writer.uint32(10).string(message.id);
        }
        for (const v of message.paths) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetWorkspacePathsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : undefined,
            paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create(base) {
        return GetWorkspacePathsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetWorkspacePathsResponse();
        message.id = object.id ?? undefined;
        message.paths = object.paths?.map((e) => e) || [];
        return message;
    },
};
function createBaseSaveOpenDocumentIfDirtyRequest() {
    return { filePath: undefined };
}
export const SaveOpenDocumentIfDirtyRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.filePath !== undefined) {
            writer.uint32(18).string(message.filePath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveOpenDocumentIfDirtyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.filePath !== undefined) {
            obj.filePath = message.filePath;
        }
        return obj;
    },
    create(base) {
        return SaveOpenDocumentIfDirtyRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSaveOpenDocumentIfDirtyRequest();
        message.filePath = object.filePath ?? undefined;
        return message;
    },
};
function createBaseSaveOpenDocumentIfDirtyResponse() {
    return { wasSaved: undefined };
}
export const SaveOpenDocumentIfDirtyResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.wasSaved !== undefined) {
            writer.uint32(8).bool(message.wasSaved);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveOpenDocumentIfDirtyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.wasSaved = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { wasSaved: isSet(object.wasSaved) ? globalThis.Boolean(object.wasSaved) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.wasSaved !== undefined) {
            obj.wasSaved = message.wasSaved;
        }
        return obj;
    },
    create(base) {
        return SaveOpenDocumentIfDirtyResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSaveOpenDocumentIfDirtyResponse();
        message.wasSaved = object.wasSaved ?? undefined;
        return message;
    },
};
export const WorkspaceServiceDefinition = {
    name: "WorkspaceService",
    fullName: "host.WorkspaceService",
    methods: {
        /** Returns a list of the top level directories of the workspace. */
        getWorkspacePaths: {
            name: "getWorkspacePaths",
            requestType: GetWorkspacePathsRequest,
            requestStream: false,
            responseType: GetWorkspacePathsResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Saves an open document if it's open in the editor and has unsaved changes.
         * Returns true if the document was saved, returns false if the document was not found, or did not
         * need to be saved.
         */
        saveOpenDocumentIfDirty: {
            name: "saveOpenDocumentIfDirty",
            requestType: SaveOpenDocumentIfDirtyRequest,
            requestStream: false,
            responseType: SaveOpenDocumentIfDirtyResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const WorkspaceServiceService = {
    /** Returns a list of the top level directories of the workspace. */
    getWorkspacePaths: {
        path: "/host.WorkspaceService/getWorkspacePaths",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(GetWorkspacePathsRequest.encode(value).finish()),
        requestDeserialize: (value) => GetWorkspacePathsRequest.decode(value),
        responseSerialize: (value) => Buffer.from(GetWorkspacePathsResponse.encode(value).finish()),
        responseDeserialize: (value) => GetWorkspacePathsResponse.decode(value),
    },
    /**
     * Saves an open document if it's open in the editor and has unsaved changes.
     * Returns true if the document was saved, returns false if the document was not found, or did not
     * need to be saved.
     */
    saveOpenDocumentIfDirty: {
        path: "/host.WorkspaceService/saveOpenDocumentIfDirty",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(SaveOpenDocumentIfDirtyRequest.encode(value).finish()),
        requestDeserialize: (value) => SaveOpenDocumentIfDirtyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(SaveOpenDocumentIfDirtyResponse.encode(value).finish()),
        responseDeserialize: (value) => SaveOpenDocumentIfDirtyResponse.decode(value),
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
