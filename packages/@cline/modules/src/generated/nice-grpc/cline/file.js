// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: cline/file.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../../bufbuild/protobuf/wire";
import { BooleanRequest, Empty, EmptyRequest, Metadata, StringArray, StringArrays, StringRequest } from "./common";
function createBaseRefreshedRules() {
    return {
        globalClineRulesToggles: undefined,
        localClineRulesToggles: undefined,
        localCursorRulesToggles: undefined,
        localWindsurfRulesToggles: undefined,
        localWorkflowToggles: undefined,
        globalWorkflowToggles: undefined,
    };
}
export const RefreshedRules = {
    encode(message, writer = new BinaryWriter()) {
        if (message.globalClineRulesToggles !== undefined) {
            ClineRulesToggles.encode(message.globalClineRulesToggles, writer.uint32(10).fork()).join();
        }
        if (message.localClineRulesToggles !== undefined) {
            ClineRulesToggles.encode(message.localClineRulesToggles, writer.uint32(18).fork()).join();
        }
        if (message.localCursorRulesToggles !== undefined) {
            ClineRulesToggles.encode(message.localCursorRulesToggles, writer.uint32(26).fork()).join();
        }
        if (message.localWindsurfRulesToggles !== undefined) {
            ClineRulesToggles.encode(message.localWindsurfRulesToggles, writer.uint32(34).fork()).join();
        }
        if (message.localWorkflowToggles !== undefined) {
            ClineRulesToggles.encode(message.localWorkflowToggles, writer.uint32(42).fork()).join();
        }
        if (message.globalWorkflowToggles !== undefined) {
            ClineRulesToggles.encode(message.globalWorkflowToggles, writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshedRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.globalClineRulesToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.localClineRulesToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.localCursorRulesToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.localWindsurfRulesToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.localWorkflowToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.globalWorkflowToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            globalClineRulesToggles: isSet(object.globalClineRulesToggles)
                ? ClineRulesToggles.fromJSON(object.globalClineRulesToggles)
                : undefined,
            localClineRulesToggles: isSet(object.localClineRulesToggles)
                ? ClineRulesToggles.fromJSON(object.localClineRulesToggles)
                : undefined,
            localCursorRulesToggles: isSet(object.localCursorRulesToggles)
                ? ClineRulesToggles.fromJSON(object.localCursorRulesToggles)
                : undefined,
            localWindsurfRulesToggles: isSet(object.localWindsurfRulesToggles)
                ? ClineRulesToggles.fromJSON(object.localWindsurfRulesToggles)
                : undefined,
            localWorkflowToggles: isSet(object.localWorkflowToggles)
                ? ClineRulesToggles.fromJSON(object.localWorkflowToggles)
                : undefined,
            globalWorkflowToggles: isSet(object.globalWorkflowToggles)
                ? ClineRulesToggles.fromJSON(object.globalWorkflowToggles)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.globalClineRulesToggles !== undefined) {
            obj.globalClineRulesToggles = ClineRulesToggles.toJSON(message.globalClineRulesToggles);
        }
        if (message.localClineRulesToggles !== undefined) {
            obj.localClineRulesToggles = ClineRulesToggles.toJSON(message.localClineRulesToggles);
        }
        if (message.localCursorRulesToggles !== undefined) {
            obj.localCursorRulesToggles = ClineRulesToggles.toJSON(message.localCursorRulesToggles);
        }
        if (message.localWindsurfRulesToggles !== undefined) {
            obj.localWindsurfRulesToggles = ClineRulesToggles.toJSON(message.localWindsurfRulesToggles);
        }
        if (message.localWorkflowToggles !== undefined) {
            obj.localWorkflowToggles = ClineRulesToggles.toJSON(message.localWorkflowToggles);
        }
        if (message.globalWorkflowToggles !== undefined) {
            obj.globalWorkflowToggles = ClineRulesToggles.toJSON(message.globalWorkflowToggles);
        }
        return obj;
    },
    create(base) {
        return RefreshedRules.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRefreshedRules();
        message.globalClineRulesToggles =
            (object.globalClineRulesToggles !== undefined && object.globalClineRulesToggles !== null)
                ? ClineRulesToggles.fromPartial(object.globalClineRulesToggles)
                : undefined;
        message.localClineRulesToggles =
            (object.localClineRulesToggles !== undefined && object.localClineRulesToggles !== null)
                ? ClineRulesToggles.fromPartial(object.localClineRulesToggles)
                : undefined;
        message.localCursorRulesToggles =
            (object.localCursorRulesToggles !== undefined && object.localCursorRulesToggles !== null)
                ? ClineRulesToggles.fromPartial(object.localCursorRulesToggles)
                : undefined;
        message.localWindsurfRulesToggles =
            (object.localWindsurfRulesToggles !== undefined && object.localWindsurfRulesToggles !== null)
                ? ClineRulesToggles.fromPartial(object.localWindsurfRulesToggles)
                : undefined;
        message.localWorkflowToggles = (object.localWorkflowToggles !== undefined && object.localWorkflowToggles !== null)
            ? ClineRulesToggles.fromPartial(object.localWorkflowToggles)
            : undefined;
        message.globalWorkflowToggles =
            (object.globalWorkflowToggles !== undefined && object.globalWorkflowToggles !== null)
                ? ClineRulesToggles.fromPartial(object.globalWorkflowToggles)
                : undefined;
        return message;
    },
};
function createBaseToggleWindsurfRuleRequest() {
    return { metadata: undefined, rulePath: "", enabled: false };
}
export const ToggleWindsurfRuleRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.rulePath !== "") {
            writer.uint32(18).string(message.rulePath);
        }
        if (message.enabled !== false) {
            writer.uint32(24).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleWindsurfRuleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.rulePath = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.enabled = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            rulePath: isSet(object.rulePath) ? globalThis.String(object.rulePath) : "",
            enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.rulePath !== "") {
            obj.rulePath = message.rulePath;
        }
        if (message.enabled !== false) {
            obj.enabled = message.enabled;
        }
        return obj;
    },
    create(base) {
        return ToggleWindsurfRuleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleWindsurfRuleRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.rulePath = object.rulePath ?? "";
        message.enabled = object.enabled ?? false;
        return message;
    },
};
function createBaseRelativePathsRequest() {
    return { metadata: undefined, uris: [] };
}
export const RelativePathsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        for (const v of message.uris) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRelativePathsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.uris.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.uris?.length) {
            obj.uris = message.uris;
        }
        return obj;
    },
    create(base) {
        return RelativePathsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRelativePathsRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.uris = object.uris?.map((e) => e) || [];
        return message;
    },
};
function createBaseRelativePaths() {
    return { paths: [] };
}
export const RelativePaths = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.paths) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRelativePaths();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create(base) {
        return RelativePaths.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRelativePaths();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
    },
};
function createBaseFileSearchRequest() {
    return { metadata: undefined, query: "", mentionsRequestId: undefined, limit: undefined };
}
export const FileSearchRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.query !== "") {
            writer.uint32(18).string(message.query);
        }
        if (message.mentionsRequestId !== undefined) {
            writer.uint32(26).string(message.mentionsRequestId);
        }
        if (message.limit !== undefined) {
            writer.uint32(32).int32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFileSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.query = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.mentionsRequestId = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            query: isSet(object.query) ? globalThis.String(object.query) : "",
            mentionsRequestId: isSet(object.mentionsRequestId) ? globalThis.String(object.mentionsRequestId) : undefined,
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.query !== "") {
            obj.query = message.query;
        }
        if (message.mentionsRequestId !== undefined) {
            obj.mentionsRequestId = message.mentionsRequestId;
        }
        if (message.limit !== undefined) {
            obj.limit = Math.round(message.limit);
        }
        return obj;
    },
    create(base) {
        return FileSearchRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFileSearchRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.query = object.query ?? "";
        message.mentionsRequestId = object.mentionsRequestId ?? undefined;
        message.limit = object.limit ?? undefined;
        return message;
    },
};
function createBaseFileSearchResults() {
    return { results: [], mentionsRequestId: undefined };
}
export const FileSearchResults = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.results) {
            FileInfo.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.mentionsRequestId !== undefined) {
            writer.uint32(18).string(message.mentionsRequestId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFileSearchResults();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(FileInfo.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.mentionsRequestId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: globalThis.Array.isArray(object?.results) ? object.results.map((e) => FileInfo.fromJSON(e)) : [],
            mentionsRequestId: isSet(object.mentionsRequestId) ? globalThis.String(object.mentionsRequestId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.results?.length) {
            obj.results = message.results.map((e) => FileInfo.toJSON(e));
        }
        if (message.mentionsRequestId !== undefined) {
            obj.mentionsRequestId = message.mentionsRequestId;
        }
        return obj;
    },
    create(base) {
        return FileSearchResults.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFileSearchResults();
        message.results = object.results?.map((e) => FileInfo.fromPartial(e)) || [];
        message.mentionsRequestId = object.mentionsRequestId ?? undefined;
        return message;
    },
};
function createBaseFileInfo() {
    return { path: "", type: "", label: undefined };
}
export const FileInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.path !== "") {
            writer.uint32(10).string(message.path);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.label !== undefined) {
            writer.uint32(26).string(message.label);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFileInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.label = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            path: isSet(object.path) ? globalThis.String(object.path) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            label: isSet(object.label) ? globalThis.String(object.label) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.path !== "") {
            obj.path = message.path;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.label !== undefined) {
            obj.label = message.label;
        }
        return obj;
    },
    create(base) {
        return FileInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFileInfo();
        message.path = object.path ?? "";
        message.type = object.type ?? "";
        message.label = object.label ?? undefined;
        return message;
    },
};
function createBaseGitCommits() {
    return { commits: [] };
}
export const GitCommits = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.commits) {
            GitCommit.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGitCommits();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.commits.push(GitCommit.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            commits: globalThis.Array.isArray(object?.commits) ? object.commits.map((e) => GitCommit.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.commits?.length) {
            obj.commits = message.commits.map((e) => GitCommit.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GitCommits.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGitCommits();
        message.commits = object.commits?.map((e) => GitCommit.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGitCommit() {
    return { hash: "", shortHash: "", subject: "", author: "", date: "" };
}
export const GitCommit = {
    encode(message, writer = new BinaryWriter()) {
        if (message.hash !== "") {
            writer.uint32(10).string(message.hash);
        }
        if (message.shortHash !== "") {
            writer.uint32(18).string(message.shortHash);
        }
        if (message.subject !== "") {
            writer.uint32(26).string(message.subject);
        }
        if (message.author !== "") {
            writer.uint32(34).string(message.author);
        }
        if (message.date !== "") {
            writer.uint32(42).string(message.date);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGitCommit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.hash = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.shortHash = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.subject = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.author = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.date = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
            shortHash: isSet(object.shortHash) ? globalThis.String(object.shortHash) : "",
            subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
            author: isSet(object.author) ? globalThis.String(object.author) : "",
            date: isSet(object.date) ? globalThis.String(object.date) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.hash !== "") {
            obj.hash = message.hash;
        }
        if (message.shortHash !== "") {
            obj.shortHash = message.shortHash;
        }
        if (message.subject !== "") {
            obj.subject = message.subject;
        }
        if (message.author !== "") {
            obj.author = message.author;
        }
        if (message.date !== "") {
            obj.date = message.date;
        }
        return obj;
    },
    create(base) {
        return GitCommit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGitCommit();
        message.hash = object.hash ?? "";
        message.shortHash = object.shortHash ?? "";
        message.subject = object.subject ?? "";
        message.author = object.author ?? "";
        message.date = object.date ?? "";
        return message;
    },
};
function createBaseRuleFileRequest() {
    return { metadata: undefined, isGlobal: false, rulePath: undefined, filename: undefined, type: undefined };
}
export const RuleFileRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.isGlobal !== false) {
            writer.uint32(16).bool(message.isGlobal);
        }
        if (message.rulePath !== undefined) {
            writer.uint32(26).string(message.rulePath);
        }
        if (message.filename !== undefined) {
            writer.uint32(34).string(message.filename);
        }
        if (message.type !== undefined) {
            writer.uint32(42).string(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRuleFileRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.isGlobal = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.rulePath = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.filename = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            isGlobal: isSet(object.isGlobal) ? globalThis.Boolean(object.isGlobal) : false,
            rulePath: isSet(object.rulePath) ? globalThis.String(object.rulePath) : undefined,
            filename: isSet(object.filename) ? globalThis.String(object.filename) : undefined,
            type: isSet(object.type) ? globalThis.String(object.type) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.isGlobal !== false) {
            obj.isGlobal = message.isGlobal;
        }
        if (message.rulePath !== undefined) {
            obj.rulePath = message.rulePath;
        }
        if (message.filename !== undefined) {
            obj.filename = message.filename;
        }
        if (message.type !== undefined) {
            obj.type = message.type;
        }
        return obj;
    },
    create(base) {
        return RuleFileRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRuleFileRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.isGlobal = object.isGlobal ?? false;
        message.rulePath = object.rulePath ?? undefined;
        message.filename = object.filename ?? undefined;
        message.type = object.type ?? undefined;
        return message;
    },
};
function createBaseRuleFile() {
    return { filePath: "", displayName: "", alreadyExists: false };
}
export const RuleFile = {
    encode(message, writer = new BinaryWriter()) {
        if (message.filePath !== "") {
            writer.uint32(10).string(message.filePath);
        }
        if (message.displayName !== "") {
            writer.uint32(18).string(message.displayName);
        }
        if (message.alreadyExists !== false) {
            writer.uint32(24).bool(message.alreadyExists);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRuleFile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.displayName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.alreadyExists = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
            displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
            alreadyExists: isSet(object.alreadyExists) ? globalThis.Boolean(object.alreadyExists) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        if (message.displayName !== "") {
            obj.displayName = message.displayName;
        }
        if (message.alreadyExists !== false) {
            obj.alreadyExists = message.alreadyExists;
        }
        return obj;
    },
    create(base) {
        return RuleFile.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRuleFile();
        message.filePath = object.filePath ?? "";
        message.displayName = object.displayName ?? "";
        message.alreadyExists = object.alreadyExists ?? false;
        return message;
    },
};
function createBaseToggleClineRuleRequest() {
    return { metadata: undefined, isGlobal: false, rulePath: "", enabled: false };
}
export const ToggleClineRuleRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.isGlobal !== false) {
            writer.uint32(16).bool(message.isGlobal);
        }
        if (message.rulePath !== "") {
            writer.uint32(26).string(message.rulePath);
        }
        if (message.enabled !== false) {
            writer.uint32(32).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleClineRuleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.isGlobal = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.rulePath = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.enabled = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            isGlobal: isSet(object.isGlobal) ? globalThis.Boolean(object.isGlobal) : false,
            rulePath: isSet(object.rulePath) ? globalThis.String(object.rulePath) : "",
            enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.isGlobal !== false) {
            obj.isGlobal = message.isGlobal;
        }
        if (message.rulePath !== "") {
            obj.rulePath = message.rulePath;
        }
        if (message.enabled !== false) {
            obj.enabled = message.enabled;
        }
        return obj;
    },
    create(base) {
        return ToggleClineRuleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleClineRuleRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.isGlobal = object.isGlobal ?? false;
        message.rulePath = object.rulePath ?? "";
        message.enabled = object.enabled ?? false;
        return message;
    },
};
function createBaseClineRulesToggles() {
    return { toggles: {} };
}
export const ClineRulesToggles = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.toggles).forEach(([key, value]) => {
            ClineRulesToggles_TogglesEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClineRulesToggles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = ClineRulesToggles_TogglesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.toggles[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            toggles: isObject(object.toggles)
                ? Object.entries(object.toggles).reduce((acc, [key, value]) => {
                    acc[key] = Boolean(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.toggles) {
            const entries = Object.entries(message.toggles);
            if (entries.length > 0) {
                obj.toggles = {};
                entries.forEach(([k, v]) => {
                    obj.toggles[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return ClineRulesToggles.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClineRulesToggles();
        message.toggles = Object.entries(object.toggles ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.Boolean(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseClineRulesToggles_TogglesEntry() {
    return { key: "", value: false };
}
export const ClineRulesToggles_TogglesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== false) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClineRulesToggles_TogglesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== false) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return ClineRulesToggles_TogglesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClineRulesToggles_TogglesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? false;
        return message;
    },
};
function createBaseToggleClineRules() {
    return { globalClineRulesToggles: undefined, localClineRulesToggles: undefined };
}
export const ToggleClineRules = {
    encode(message, writer = new BinaryWriter()) {
        if (message.globalClineRulesToggles !== undefined) {
            ClineRulesToggles.encode(message.globalClineRulesToggles, writer.uint32(10).fork()).join();
        }
        if (message.localClineRulesToggles !== undefined) {
            ClineRulesToggles.encode(message.localClineRulesToggles, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleClineRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.globalClineRulesToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.localClineRulesToggles = ClineRulesToggles.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            globalClineRulesToggles: isSet(object.globalClineRulesToggles)
                ? ClineRulesToggles.fromJSON(object.globalClineRulesToggles)
                : undefined,
            localClineRulesToggles: isSet(object.localClineRulesToggles)
                ? ClineRulesToggles.fromJSON(object.localClineRulesToggles)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.globalClineRulesToggles !== undefined) {
            obj.globalClineRulesToggles = ClineRulesToggles.toJSON(message.globalClineRulesToggles);
        }
        if (message.localClineRulesToggles !== undefined) {
            obj.localClineRulesToggles = ClineRulesToggles.toJSON(message.localClineRulesToggles);
        }
        return obj;
    },
    create(base) {
        return ToggleClineRules.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleClineRules();
        message.globalClineRulesToggles =
            (object.globalClineRulesToggles !== undefined && object.globalClineRulesToggles !== null)
                ? ClineRulesToggles.fromPartial(object.globalClineRulesToggles)
                : undefined;
        message.localClineRulesToggles =
            (object.localClineRulesToggles !== undefined && object.localClineRulesToggles !== null)
                ? ClineRulesToggles.fromPartial(object.localClineRulesToggles)
                : undefined;
        return message;
    },
};
function createBaseToggleCursorRuleRequest() {
    return { metadata: undefined, rulePath: "", enabled: false };
}
export const ToggleCursorRuleRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.rulePath !== "") {
            writer.uint32(18).string(message.rulePath);
        }
        if (message.enabled !== false) {
            writer.uint32(24).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleCursorRuleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.rulePath = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.enabled = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            rulePath: isSet(object.rulePath) ? globalThis.String(object.rulePath) : "",
            enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.rulePath !== "") {
            obj.rulePath = message.rulePath;
        }
        if (message.enabled !== false) {
            obj.enabled = message.enabled;
        }
        return obj;
    },
    create(base) {
        return ToggleCursorRuleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleCursorRuleRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.rulePath = object.rulePath ?? "";
        message.enabled = object.enabled ?? false;
        return message;
    },
};
function createBaseToggleWorkflowRequest() {
    return { metadata: undefined, workflowPath: "", enabled: false, isGlobal: false };
}
export const ToggleWorkflowRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.workflowPath !== "") {
            writer.uint32(18).string(message.workflowPath);
        }
        if (message.enabled !== false) {
            writer.uint32(24).bool(message.enabled);
        }
        if (message.isGlobal !== false) {
            writer.uint32(32).bool(message.isGlobal);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleWorkflowRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.workflowPath = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.enabled = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.isGlobal = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            workflowPath: isSet(object.workflowPath) ? globalThis.String(object.workflowPath) : "",
            enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
            isGlobal: isSet(object.isGlobal) ? globalThis.Boolean(object.isGlobal) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.workflowPath !== "") {
            obj.workflowPath = message.workflowPath;
        }
        if (message.enabled !== false) {
            obj.enabled = message.enabled;
        }
        if (message.isGlobal !== false) {
            obj.isGlobal = message.isGlobal;
        }
        return obj;
    },
    create(base) {
        return ToggleWorkflowRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleWorkflowRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.workflowPath = object.workflowPath ?? "";
        message.enabled = object.enabled ?? false;
        message.isGlobal = object.isGlobal ?? false;
        return message;
    },
};
export const FileServiceDefinition = {
    name: "FileService",
    fullName: "cline.FileService",
    methods: {
        /** Copies text to clipboard */
        copyToClipboard: {
            name: "copyToClipboard",
            requestType: StringRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Opens a file in the editor */
        openFile: {
            name: "openFile",
            requestType: StringRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Opens an image in the system viewer */
        openImage: {
            name: "openImage",
            requestType: StringRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Opens a mention (file, path, git commit, problem, terminal, or URL) */
        openMention: {
            name: "openMention",
            requestType: StringRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Deletes a rule file from either global or workspace rules directory */
        deleteRuleFile: {
            name: "deleteRuleFile",
            requestType: RuleFileRequest,
            requestStream: false,
            responseType: RuleFile,
            responseStream: false,
            options: {},
        },
        /** Creates a rule file from either global or workspace rules directory */
        createRuleFile: {
            name: "createRuleFile",
            requestType: RuleFileRequest,
            requestStream: false,
            responseType: RuleFile,
            responseStream: false,
            options: {},
        },
        /** Search git commits in the workspace */
        searchCommits: {
            name: "searchCommits",
            requestType: StringRequest,
            requestStream: false,
            responseType: GitCommits,
            responseStream: false,
            options: {},
        },
        /** Select images and other files from the file system and returns as data URLs & paths respectively */
        selectFiles: {
            name: "selectFiles",
            requestType: BooleanRequest,
            requestStream: false,
            responseType: StringArrays,
            responseStream: false,
            options: {},
        },
        /** Convert URIs to workspace-relative paths */
        getRelativePaths: {
            name: "getRelativePaths",
            requestType: RelativePathsRequest,
            requestStream: false,
            responseType: RelativePaths,
            responseStream: false,
            options: {},
        },
        /** Search for files in the workspace with fuzzy matching */
        searchFiles: {
            name: "searchFiles",
            requestType: FileSearchRequest,
            requestStream: false,
            responseType: FileSearchResults,
            responseStream: false,
            options: {},
        },
        /** Toggle a Cline rule (enable or disable) */
        toggleClineRule: {
            name: "toggleClineRule",
            requestType: ToggleClineRuleRequest,
            requestStream: false,
            responseType: ToggleClineRules,
            responseStream: false,
            options: {},
        },
        /** Toggle a Cursor rule (enable or disable) */
        toggleCursorRule: {
            name: "toggleCursorRule",
            requestType: ToggleCursorRuleRequest,
            requestStream: false,
            responseType: ClineRulesToggles,
            responseStream: false,
            options: {},
        },
        /** Toggle a Windsurf rule (enable or disable) */
        toggleWindsurfRule: {
            name: "toggleWindsurfRule",
            requestType: ToggleWindsurfRuleRequest,
            requestStream: false,
            responseType: ClineRulesToggles,
            responseStream: false,
            options: {},
        },
        /** Refreshes all rule toggles (Cline, External, and Workflows) */
        refreshRules: {
            name: "refreshRules",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: RefreshedRules,
            responseStream: false,
            options: {},
        },
        /** Opens a task's conversation history file on disk */
        openTaskHistory: {
            name: "openTaskHistory",
            requestType: StringRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Toggles a workflow on or off */
        toggleWorkflow: {
            name: "toggleWorkflow",
            requestType: ToggleWorkflowRequest,
            requestStream: false,
            responseType: ClineRulesToggles,
            responseStream: false,
            options: {},
        },
        /** Subscribe to workspace file updates */
        subscribeToWorkspaceUpdates: {
            name: "subscribeToWorkspaceUpdates",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: StringArray,
            responseStream: true,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
