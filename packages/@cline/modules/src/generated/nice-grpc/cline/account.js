// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: cline/account.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../../bufbuild/protobuf/wire";
import { Empty, EmptyRequest, Metadata, String } from "./common";
function createBaseAuthStateChangedRequest() {
    return { metadata: undefined, user: undefined };
}
export const AuthStateChangedRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.user !== undefined) {
            UserInfo.encode(message.user, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthStateChangedRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.user = UserInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.user !== undefined) {
            obj.user = UserInfo.toJSON(message.user);
        }
        return obj;
    },
    create(base) {
        return AuthStateChangedRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuthStateChangedRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
        return message;
    },
};
function createBaseAuthState() {
    return { user: undefined };
}
export const AuthState = {
    encode(message, writer = new BinaryWriter()) {
        if (message.user !== undefined) {
            UserInfo.encode(message.user, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.user = UserInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.user !== undefined) {
            obj.user = UserInfo.toJSON(message.user);
        }
        return obj;
    },
    create(base) {
        return AuthState.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuthState();
        message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
        return message;
    },
};
function createBaseUserInfo() {
    return { uid: "", displayName: undefined, email: undefined, photoUrl: undefined, appBaseUrl: undefined };
}
export const UserInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uid !== "") {
            writer.uint32(10).string(message.uid);
        }
        if (message.displayName !== undefined) {
            writer.uint32(18).string(message.displayName);
        }
        if (message.email !== undefined) {
            writer.uint32(26).string(message.email);
        }
        if (message.photoUrl !== undefined) {
            writer.uint32(34).string(message.photoUrl);
        }
        if (message.appBaseUrl !== undefined) {
            writer.uint32(42).string(message.appBaseUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.displayName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.email = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.photoUrl = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.appBaseUrl = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
            displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
            email: isSet(object.email) ? globalThis.String(object.email) : undefined,
            photoUrl: isSet(object.photoUrl) ? globalThis.String(object.photoUrl) : undefined,
            appBaseUrl: isSet(object.appBaseUrl) ? globalThis.String(object.appBaseUrl) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uid !== "") {
            obj.uid = message.uid;
        }
        if (message.displayName !== undefined) {
            obj.displayName = message.displayName;
        }
        if (message.email !== undefined) {
            obj.email = message.email;
        }
        if (message.photoUrl !== undefined) {
            obj.photoUrl = message.photoUrl;
        }
        if (message.appBaseUrl !== undefined) {
            obj.appBaseUrl = message.appBaseUrl;
        }
        return obj;
    },
    create(base) {
        return UserInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserInfo();
        message.uid = object.uid ?? "";
        message.displayName = object.displayName ?? undefined;
        message.email = object.email ?? undefined;
        message.photoUrl = object.photoUrl ?? undefined;
        message.appBaseUrl = object.appBaseUrl ?? undefined;
        return message;
    },
};
function createBaseUserOrganization() {
    return { active: false, memberId: "", name: "", organizationId: "", roles: [] };
}
export const UserOrganization = {
    encode(message, writer = new BinaryWriter()) {
        if (message.active !== false) {
            writer.uint32(8).bool(message.active);
        }
        if (message.memberId !== "") {
            writer.uint32(18).string(message.memberId);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.organizationId !== "") {
            writer.uint32(34).string(message.organizationId);
        }
        for (const v of message.roles) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserOrganization();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.active = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.memberId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.organizationId = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.roles.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
            memberId: isSet(object.memberId) ? globalThis.String(object.memberId) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
            roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.active !== false) {
            obj.active = message.active;
        }
        if (message.memberId !== "") {
            obj.memberId = message.memberId;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.organizationId !== "") {
            obj.organizationId = message.organizationId;
        }
        if (message.roles?.length) {
            obj.roles = message.roles;
        }
        return obj;
    },
    create(base) {
        return UserOrganization.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserOrganization();
        message.active = object.active ?? false;
        message.memberId = object.memberId ?? "";
        message.name = object.name ?? "";
        message.organizationId = object.organizationId ?? "";
        message.roles = object.roles?.map((e) => e) || [];
        return message;
    },
};
function createBaseUserOrganizationsResponse() {
    return { organizations: [] };
}
export const UserOrganizationsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.organizations) {
            UserOrganization.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserOrganizationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.organizations.push(UserOrganization.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            organizations: globalThis.Array.isArray(object?.organizations)
                ? object.organizations.map((e) => UserOrganization.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.organizations?.length) {
            obj.organizations = message.organizations.map((e) => UserOrganization.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UserOrganizationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserOrganizationsResponse();
        message.organizations = object.organizations?.map((e) => UserOrganization.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUserOrganizationUpdateRequest() {
    return { organizationId: undefined };
}
export const UserOrganizationUpdateRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.organizationId !== undefined) {
            writer.uint32(10).string(message.organizationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserOrganizationUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.organizationId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.organizationId !== undefined) {
            obj.organizationId = message.organizationId;
        }
        return obj;
    },
    create(base) {
        return UserOrganizationUpdateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserOrganizationUpdateRequest();
        message.organizationId = object.organizationId ?? undefined;
        return message;
    },
};
function createBaseUserCreditsData() {
    return { balance: undefined, usageTransactions: [], paymentTransactions: [] };
}
export const UserCreditsData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.balance !== undefined) {
            UserCreditsBalance.encode(message.balance, writer.uint32(10).fork()).join();
        }
        for (const v of message.usageTransactions) {
            UsageTransaction.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.paymentTransactions) {
            PaymentTransaction.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserCreditsData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.balance = UserCreditsBalance.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.usageTransactions.push(UsageTransaction.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.paymentTransactions.push(PaymentTransaction.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            balance: isSet(object.balance) ? UserCreditsBalance.fromJSON(object.balance) : undefined,
            usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
                ? object.usageTransactions.map((e) => UsageTransaction.fromJSON(e))
                : [],
            paymentTransactions: globalThis.Array.isArray(object?.paymentTransactions)
                ? object.paymentTransactions.map((e) => PaymentTransaction.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balance !== undefined) {
            obj.balance = UserCreditsBalance.toJSON(message.balance);
        }
        if (message.usageTransactions?.length) {
            obj.usageTransactions = message.usageTransactions.map((e) => UsageTransaction.toJSON(e));
        }
        if (message.paymentTransactions?.length) {
            obj.paymentTransactions = message.paymentTransactions.map((e) => PaymentTransaction.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UserCreditsData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserCreditsData();
        message.balance = (object.balance !== undefined && object.balance !== null)
            ? UserCreditsBalance.fromPartial(object.balance)
            : undefined;
        message.usageTransactions = object.usageTransactions?.map((e) => UsageTransaction.fromPartial(e)) || [];
        message.paymentTransactions = object.paymentTransactions?.map((e) => PaymentTransaction.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetOrganizationCreditsRequest() {
    return { organizationId: "" };
}
export const GetOrganizationCreditsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.organizationId !== "") {
            writer.uint32(10).string(message.organizationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOrganizationCreditsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.organizationId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.organizationId !== "") {
            obj.organizationId = message.organizationId;
        }
        return obj;
    },
    create(base) {
        return GetOrganizationCreditsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetOrganizationCreditsRequest();
        message.organizationId = object.organizationId ?? "";
        return message;
    },
};
function createBaseOrganizationCreditsData() {
    return { balance: undefined, organizationId: "", usageTransactions: [] };
}
export const OrganizationCreditsData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.balance !== undefined) {
            UserCreditsBalance.encode(message.balance, writer.uint32(10).fork()).join();
        }
        if (message.organizationId !== "") {
            writer.uint32(18).string(message.organizationId);
        }
        for (const v of message.usageTransactions) {
            OrganizationUsageTransaction.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrganizationCreditsData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.balance = UserCreditsBalance.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.organizationId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.usageTransactions.push(OrganizationUsageTransaction.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            balance: isSet(object.balance) ? UserCreditsBalance.fromJSON(object.balance) : undefined,
            organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
            usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
                ? object.usageTransactions.map((e) => OrganizationUsageTransaction.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balance !== undefined) {
            obj.balance = UserCreditsBalance.toJSON(message.balance);
        }
        if (message.organizationId !== "") {
            obj.organizationId = message.organizationId;
        }
        if (message.usageTransactions?.length) {
            obj.usageTransactions = message.usageTransactions.map((e) => OrganizationUsageTransaction.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return OrganizationCreditsData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrganizationCreditsData();
        message.balance = (object.balance !== undefined && object.balance !== null)
            ? UserCreditsBalance.fromPartial(object.balance)
            : undefined;
        message.organizationId = object.organizationId ?? "";
        message.usageTransactions = object.usageTransactions?.map((e) => OrganizationUsageTransaction.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUserCreditsBalance() {
    return { currentBalance: 0 };
}
export const UserCreditsBalance = {
    encode(message, writer = new BinaryWriter()) {
        if (message.currentBalance !== 0) {
            writer.uint32(9).double(message.currentBalance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserCreditsBalance();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 9) {
                        break;
                    }
                    message.currentBalance = reader.double();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { currentBalance: isSet(object.currentBalance) ? globalThis.Number(object.currentBalance) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.currentBalance !== 0) {
            obj.currentBalance = message.currentBalance;
        }
        return obj;
    },
    create(base) {
        return UserCreditsBalance.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserCreditsBalance();
        message.currentBalance = object.currentBalance ?? 0;
        return message;
    },
};
function createBaseUsageTransaction() {
    return {
        aiInferenceProviderName: "",
        aiModelName: "",
        aiModelTypeName: "",
        completionTokens: 0,
        costUsd: 0,
        createdAt: "",
        creditsUsed: 0,
        generationId: "",
        organizationId: "",
        promptTokens: 0,
        totalTokens: 0,
        userId: "",
    };
}
export const UsageTransaction = {
    encode(message, writer = new BinaryWriter()) {
        if (message.aiInferenceProviderName !== "") {
            writer.uint32(10).string(message.aiInferenceProviderName);
        }
        if (message.aiModelName !== "") {
            writer.uint32(18).string(message.aiModelName);
        }
        if (message.aiModelTypeName !== "") {
            writer.uint32(26).string(message.aiModelTypeName);
        }
        if (message.completionTokens !== 0) {
            writer.uint32(32).int32(message.completionTokens);
        }
        if (message.costUsd !== 0) {
            writer.uint32(41).double(message.costUsd);
        }
        if (message.createdAt !== "") {
            writer.uint32(50).string(message.createdAt);
        }
        if (message.creditsUsed !== 0) {
            writer.uint32(57).double(message.creditsUsed);
        }
        if (message.generationId !== "") {
            writer.uint32(66).string(message.generationId);
        }
        if (message.organizationId !== "") {
            writer.uint32(74).string(message.organizationId);
        }
        if (message.promptTokens !== 0) {
            writer.uint32(80).int32(message.promptTokens);
        }
        if (message.totalTokens !== 0) {
            writer.uint32(88).int32(message.totalTokens);
        }
        if (message.userId !== "") {
            writer.uint32(98).string(message.userId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUsageTransaction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.aiInferenceProviderName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.aiModelName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.aiModelTypeName = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.completionTokens = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.costUsd = reader.double();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.createdAt = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 57) {
                        break;
                    }
                    message.creditsUsed = reader.double();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.generationId = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.organizationId = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.promptTokens = reader.int32();
                    continue;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.totalTokens = reader.int32();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            aiInferenceProviderName: isSet(object.aiInferenceProviderName)
                ? globalThis.String(object.aiInferenceProviderName)
                : "",
            aiModelName: isSet(object.aiModelName) ? globalThis.String(object.aiModelName) : "",
            aiModelTypeName: isSet(object.aiModelTypeName) ? globalThis.String(object.aiModelTypeName) : "",
            completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
            costUsd: isSet(object.costUsd) ? globalThis.Number(object.costUsd) : 0,
            createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
            creditsUsed: isSet(object.creditsUsed) ? globalThis.Number(object.creditsUsed) : 0,
            generationId: isSet(object.generationId) ? globalThis.String(object.generationId) : "",
            organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
            promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
            totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.aiInferenceProviderName !== "") {
            obj.aiInferenceProviderName = message.aiInferenceProviderName;
        }
        if (message.aiModelName !== "") {
            obj.aiModelName = message.aiModelName;
        }
        if (message.aiModelTypeName !== "") {
            obj.aiModelTypeName = message.aiModelTypeName;
        }
        if (message.completionTokens !== 0) {
            obj.completionTokens = Math.round(message.completionTokens);
        }
        if (message.costUsd !== 0) {
            obj.costUsd = message.costUsd;
        }
        if (message.createdAt !== "") {
            obj.createdAt = message.createdAt;
        }
        if (message.creditsUsed !== 0) {
            obj.creditsUsed = message.creditsUsed;
        }
        if (message.generationId !== "") {
            obj.generationId = message.generationId;
        }
        if (message.organizationId !== "") {
            obj.organizationId = message.organizationId;
        }
        if (message.promptTokens !== 0) {
            obj.promptTokens = Math.round(message.promptTokens);
        }
        if (message.totalTokens !== 0) {
            obj.totalTokens = Math.round(message.totalTokens);
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        return obj;
    },
    create(base) {
        return UsageTransaction.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUsageTransaction();
        message.aiInferenceProviderName = object.aiInferenceProviderName ?? "";
        message.aiModelName = object.aiModelName ?? "";
        message.aiModelTypeName = object.aiModelTypeName ?? "";
        message.completionTokens = object.completionTokens ?? 0;
        message.costUsd = object.costUsd ?? 0;
        message.createdAt = object.createdAt ?? "";
        message.creditsUsed = object.creditsUsed ?? 0;
        message.generationId = object.generationId ?? "";
        message.organizationId = object.organizationId ?? "";
        message.promptTokens = object.promptTokens ?? 0;
        message.totalTokens = object.totalTokens ?? 0;
        message.userId = object.userId ?? "";
        return message;
    },
};
function createBasePaymentTransaction() {
    return { paidAt: "", creatorId: "", amountCents: 0, credits: 0 };
}
export const PaymentTransaction = {
    encode(message, writer = new BinaryWriter()) {
        if (message.paidAt !== "") {
            writer.uint32(10).string(message.paidAt);
        }
        if (message.creatorId !== "") {
            writer.uint32(18).string(message.creatorId);
        }
        if (message.amountCents !== 0) {
            writer.uint32(24).int32(message.amountCents);
        }
        if (message.credits !== 0) {
            writer.uint32(33).double(message.credits);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePaymentTransaction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paidAt = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.creatorId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.amountCents = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }
                    message.credits = reader.double();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            paidAt: isSet(object.paidAt) ? globalThis.String(object.paidAt) : "",
            creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
            amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
            credits: isSet(object.credits) ? globalThis.Number(object.credits) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paidAt !== "") {
            obj.paidAt = message.paidAt;
        }
        if (message.creatorId !== "") {
            obj.creatorId = message.creatorId;
        }
        if (message.amountCents !== 0) {
            obj.amountCents = Math.round(message.amountCents);
        }
        if (message.credits !== 0) {
            obj.credits = message.credits;
        }
        return obj;
    },
    create(base) {
        return PaymentTransaction.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePaymentTransaction();
        message.paidAt = object.paidAt ?? "";
        message.creatorId = object.creatorId ?? "";
        message.amountCents = object.amountCents ?? 0;
        message.credits = object.credits ?? 0;
        return message;
    },
};
function createBaseOrganizationUsageTransaction() {
    return {
        aiInferenceProviderName: "",
        aiModelName: "",
        aiModelTypeName: "",
        completionTokens: 0,
        costUsd: 0,
        createdAt: "",
        creditsUsed: 0,
        generationId: "",
        organizationId: "",
        promptTokens: 0,
        totalTokens: 0,
        userId: "",
    };
}
export const OrganizationUsageTransaction = {
    encode(message, writer = new BinaryWriter()) {
        if (message.aiInferenceProviderName !== "") {
            writer.uint32(10).string(message.aiInferenceProviderName);
        }
        if (message.aiModelName !== "") {
            writer.uint32(18).string(message.aiModelName);
        }
        if (message.aiModelTypeName !== "") {
            writer.uint32(26).string(message.aiModelTypeName);
        }
        if (message.completionTokens !== 0) {
            writer.uint32(32).int32(message.completionTokens);
        }
        if (message.costUsd !== 0) {
            writer.uint32(41).double(message.costUsd);
        }
        if (message.createdAt !== "") {
            writer.uint32(50).string(message.createdAt);
        }
        if (message.creditsUsed !== 0) {
            writer.uint32(57).double(message.creditsUsed);
        }
        if (message.generationId !== "") {
            writer.uint32(66).string(message.generationId);
        }
        if (message.organizationId !== "") {
            writer.uint32(74).string(message.organizationId);
        }
        if (message.promptTokens !== 0) {
            writer.uint32(80).int32(message.promptTokens);
        }
        if (message.totalTokens !== 0) {
            writer.uint32(88).int32(message.totalTokens);
        }
        if (message.userId !== "") {
            writer.uint32(98).string(message.userId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrganizationUsageTransaction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.aiInferenceProviderName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.aiModelName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.aiModelTypeName = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.completionTokens = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.costUsd = reader.double();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.createdAt = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 57) {
                        break;
                    }
                    message.creditsUsed = reader.double();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.generationId = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.organizationId = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.promptTokens = reader.int32();
                    continue;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.totalTokens = reader.int32();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            aiInferenceProviderName: isSet(object.aiInferenceProviderName)
                ? globalThis.String(object.aiInferenceProviderName)
                : "",
            aiModelName: isSet(object.aiModelName) ? globalThis.String(object.aiModelName) : "",
            aiModelTypeName: isSet(object.aiModelTypeName) ? globalThis.String(object.aiModelTypeName) : "",
            completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
            costUsd: isSet(object.costUsd) ? globalThis.Number(object.costUsd) : 0,
            createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
            creditsUsed: isSet(object.creditsUsed) ? globalThis.Number(object.creditsUsed) : 0,
            generationId: isSet(object.generationId) ? globalThis.String(object.generationId) : "",
            organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
            promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
            totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.aiInferenceProviderName !== "") {
            obj.aiInferenceProviderName = message.aiInferenceProviderName;
        }
        if (message.aiModelName !== "") {
            obj.aiModelName = message.aiModelName;
        }
        if (message.aiModelTypeName !== "") {
            obj.aiModelTypeName = message.aiModelTypeName;
        }
        if (message.completionTokens !== 0) {
            obj.completionTokens = Math.round(message.completionTokens);
        }
        if (message.costUsd !== 0) {
            obj.costUsd = message.costUsd;
        }
        if (message.createdAt !== "") {
            obj.createdAt = message.createdAt;
        }
        if (message.creditsUsed !== 0) {
            obj.creditsUsed = message.creditsUsed;
        }
        if (message.generationId !== "") {
            obj.generationId = message.generationId;
        }
        if (message.organizationId !== "") {
            obj.organizationId = message.organizationId;
        }
        if (message.promptTokens !== 0) {
            obj.promptTokens = Math.round(message.promptTokens);
        }
        if (message.totalTokens !== 0) {
            obj.totalTokens = Math.round(message.totalTokens);
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        return obj;
    },
    create(base) {
        return OrganizationUsageTransaction.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrganizationUsageTransaction();
        message.aiInferenceProviderName = object.aiInferenceProviderName ?? "";
        message.aiModelName = object.aiModelName ?? "";
        message.aiModelTypeName = object.aiModelTypeName ?? "";
        message.completionTokens = object.completionTokens ?? 0;
        message.costUsd = object.costUsd ?? 0;
        message.createdAt = object.createdAt ?? "";
        message.creditsUsed = object.creditsUsed ?? 0;
        message.generationId = object.generationId ?? "";
        message.organizationId = object.organizationId ?? "";
        message.promptTokens = object.promptTokens ?? 0;
        message.totalTokens = object.totalTokens ?? 0;
        message.userId = object.userId ?? "";
        return message;
    },
};
export const AccountServiceDefinition = {
    name: "AccountService",
    fullName: "cline.AccountService",
    methods: {
        /**
         * Handles the user clicking the login link in the UI.
         * Generates a secure nonce for state validation, stores it in secrets,
         * and opens the authentication URL in the external browser.
         */
        accountLoginClicked: {
            name: "accountLoginClicked",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: String,
            responseStream: false,
            options: {},
        },
        /**
         * Handles the user clicking the logout button in the UI.
         * Clears API keys and user state.
         */
        accountLogoutClicked: {
            name: "accountLogoutClicked",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** Subscribe to auth status update events (when authentication state changes) */
        subscribeToAuthStatusUpdate: {
            name: "subscribeToAuthStatusUpdate",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: AuthState,
            responseStream: true,
            options: {},
        },
        /**
         * Handles authentication state changes from the Firebase context.
         * Updates the user info in global state and returns the updated value.
         */
        authStateChanged: {
            name: "authStateChanged",
            requestType: AuthStateChangedRequest,
            requestStream: false,
            responseType: AuthState,
            responseStream: false,
            options: {},
        },
        /**
         * Fetches all user credits data
         * (balance, usage transactions, payment transactions)
         */
        getUserCredits: {
            name: "getUserCredits",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: UserCreditsData,
            responseStream: false,
            options: {},
        },
        getOrganizationCredits: {
            name: "getOrganizationCredits",
            requestType: GetOrganizationCreditsRequest,
            requestStream: false,
            responseType: OrganizationCreditsData,
            responseStream: false,
            options: {},
        },
        /**
         * Fetches all user organizations data
         * Returns a list of UserOrganization objects
         */
        getUserOrganizations: {
            name: "getUserOrganizations",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: UserOrganizationsResponse,
            responseStream: false,
            options: {},
        },
        setUserOrganization: {
            name: "setUserOrganization",
            requestType: UserOrganizationUpdateRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
